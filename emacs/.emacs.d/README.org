* About
#+TITLE: Wolfe's Literate Emacs Config
#+AUTHOR: Josh Wolfe
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+LATEX_HEADER: \usepackage[margin=0.7in]{geometry}
#+HTML: <a href="https://travis-ci.org/WolfeCub/dotfiles"><img style="width:90px" src="https://travis-ci.org/WolfeCub/dotfiles.svg?branch=master" alt="Build Status"/></a><br><br>

This literate config is best read [[http://wolfecub.github.io/dotfiles/][here]] or in emacs.
This page is generated and kept up to date using a combination of
[[https://travis-ci.org/WolfeCub/dotfiles/][travis ci]] and [[https://github.com/fniessen/org-html-themes][ReadTheOrg]]. If you want to see the script that travis
uses [[https://github.com/WolfeCub/dotfiles/blob/master/.travis/build_site.sh][here]] is the bash script it runs and [[https://github.com/WolfeCub/dotfiles/blob/master/.travis/generate-html.el][this]] is the =.el= file that
it runs through emacs to generate the html page (this was mostly stolen
from IvanMalison).

Included in this section is also my export headers. These are responsible
for including the ReadTheOrg theme as well as some metadata and options
like title, author, table of contents etc. If you wish to see the headers
I'm using, [[https://raw.githubusercontent.com/WolfeCub/dotfiles/master/emacs/.emacs.d/README.org][this]] is the raw org file.

Right off the bat we want these libraries but they don't really belong
anywhere else. So here they are.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash)
  (use-package s)
#+END_SRC

* Variables

Variables come at the beginning so that they're consistently available.
If you don't care about these *[[Startup][click here to skip over them]]*.

** Config Name

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/literate-config-name "README.org"
    "The name of my literate config")
#+END_SRC

** Init File

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/init-file (concat user-emacs-directory wolfe/literate-config-name)
    "The path to my literate config file")
#+END_SRC

** Linux Check

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/linux? (eq system-type 'gnu/linux)
    "Are we on linux?")
#+END_SRC

** Windows Check

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar wolfe/windows? (eq system-type 'windows-nt)
    "Are we on windows?")
#+END_SRC

** Org Ellipsis

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/org-ellipsis "⤵"
    "The indicates if an `org-mode' tree can be expanded")
#+END_SRC

** Project Path

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/project-path
    (cond
     (wolfe/linux? "~/Projects/")
     (wolfe/windows? "C:/dev/")
     (:else nil))
    "Path to my projects directory")
#+END_SRC

** Dropbox Path

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/org-dropbox-path
    (cond
     (wolfe/linux?
      "~/Dropbox/org/")
     (wolfe/windows?
      (concat "C:\\Users\\" (getenv "USERNAME") "\\Dropbox\\org\\"))
     (:else nil))
    "Path to my org files inside dropbox")
#+END_SRC

** Theme Checks

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/using-dark t
    "Indicates whether we're using my dark theme")
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/using-light nil
    "Indicates whether we're using my light theme")
#+END_SRC

** Lisp Path Location

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/lisp-dir-path "~/.emacs.d/lisp/"
    "Path to my custom lisp files")
#+END_SRC

** Highlight Escapes Modes

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/highlight-escapes-mode-list '(python-mode
                                              c-mode
                                              c++-mode
                                              web-mode)
    "List of modes to highlight escape characters in")
#+END_SRC

** IRC Info Path

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar wolfe/irc-info-path "~/.ircinfo.gpg"
    "Location of the GPG encrypted file that has my irc login info")
#+END_SRC

* Startup

My graphical settings change depending on whether I'm in terminal
and if a command line flag (=-light=) was specified.

** WM

Start load emacs window manager config if it exists.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (file-exists-p "~/.exwm.org")
    (org-babel-load-file "~/.exwm.org"))
#+END_SRC

** Theme Setup

This should be run regardless of whether I'm in terminal vs gui or dark vs light.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq custom-theme-directory "~/.emacs.d/themes")

  (defun check-and-remove-command-line-arg (argument)
    "Checks `command-line-args' for argument and removes it if found returning t or nil"
    (if (member argument command-line-args)
        (progn
          (setq command-line-args (delete argument command-line-args))
          t)
      nil))

  (let ((result (check-and-remove-command-line-arg "-light")))
    (setq wolfe/using-light result)
    (setq wolfe/using-dark (not result)))
#+END_SRC

** Dark

Configuration for my dark theme =base16 default dark= which is loaded by default.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/dark-setup ()
    (setq evil-emacs-state-cursor   `(,"#81a2be" box)
          evil-insert-state-cursor  `(,"#81a2be" bar)
          evil-motion-state-cursor  `(,"#85678f" box)
          evil-normal-state-cursor  `(,"#f8f8f8" box)
          evil-replace-state-cursor `(,"#a54242" (hbar . 10))
          evil-visual-state-cursor  `(,"#ff6000" box))
    (load-theme 'my t)
    (set-face-attribute 'fringe nil :background nil)
    (eval-after-load 'ivy (lambda () (setq ivy-switch-buffer-faces-alist '((dired-mode . ivy-subdir)))))

    (custom-set-faces
     '(org-done ((t (:box (:line-width 1) :weight bold))))
     '(org-level-1 ((t (:inherit outline-1 :height 1.3))))
     '(org-todo ((t (:box (:line-width 1) :weight bold))))))
#+END_SRC

** Light

Configuration for my light theme =leuven=. This is only loaded when the =-light= flag is
specified on the command line.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/light-setup ()
    (use-package leuven-theme
      :config
      (custom-set-faces
       '(ivy-subdir ((t (:background "gray88")))))
      (load-theme 'leuven t)))
#+END_SRC

** Display check

This checks which setup we're in and calls the appropriate function above.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hook-if-daemonp (func)
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (with-selected-frame frame
                      (funcall func))))
      (funcall func)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (if wolfe/using-light
      (wolfe/light-setup)
    (wolfe/dark-setup))
#+END_SRC

* General Settings

Basic settings I can't really live without.

** Load Path

Recursively add =~/.emacs.d/lisp/= to my load path.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path wolfe/lisp-dir-path)
  (let ((default-directory wolfe/lisp-dir-path))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

** Splash and Startup

This makes sure I'm presented with a nice blank =*scratch*=
buffer when emacs starts up.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-splash-screen t
        inhibit-startup-message t
        initial-scratch-message "") ; No scratch text
  (defun display-startup-echo-area-message ()
    (message "Welcome to the church of GNU/Emacs"))
#+END_SRC

** Graphics
*** Bars

I don't really want to have to look at menu bars that I'm not going to use

#+BEGIN_SRC emacs-lisp :tangle yes
  (hook-if-daemonp
   (lambda ()
    (tool-bar-mode -1) ; No toolbar
    (scroll-bar-mode -1) ; Hide scrollbars
    (menu-bar-mode -1))) ; No menubar
#+END_SRC

*** Fonts

I used =Inconsolata-dz= for quite a long time but have recently been
using =Fira Mono=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (let* ((font "Fira Mono")
         (size 15)
         (font-size (format "%s-%s" font size)))
    (setq default-frame-alist `((font . ,font-size)))
    (set-face-attribute 'default t :font font-size))
#+END_SRC

Force =Fira Code= for all =UTF-8= symbols.

#+BEGIN_SRC emacs-lisp :tangle yes
  (hook-if-daemonp
   (lambda ()
    (when (display-graphic-p)
      (let ((utf8-font "Fira Code"))
        (set-fontset-font "fontset-startup" '(#x000000 . #x3FFFFF) utf8-font)
        (set-fontset-font "fontset-default" '(#x000000 . #x3FFFFF) utf8-font)
        (set-fontset-font "fontset-standard" '(#x000000 . #x3FFFFF) utf8-font)))))
#+END_SRC

Make sure that UTF-8 is used everywhere.

#+BEGIN_SRC emacs-lisp :tangle yes
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-language-environment    'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq locale-coding-system   'utf-8)
  (prefer-coding-system        'utf-8)
  (set-input-method nil)
#+END_SRC

*** Pretty Symbols

In emacs =24.4= we got =prettify-symbols-mode= which replaces things like =lambda=
with =λ=. This can help make the code easier to read. The =inhibit-compacting-font-caches=
stops garbage collect from trying to handle font caches which makes things a lot faster
and saves us ram.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (setq inhibit-compacting-font-caches t)
#+END_SRC

**** Global

These symbols are the basics that I would like enabled for all =prog-mode= modes.
This function can be called by the mode specific hook to push the defaults.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/pretty-symbol-push-default ()
    (push '("!=" . ?≠) prettify-symbols-alist)
    (push '("<=" . ?≤) prettify-symbols-alist)
    (push '(">=" . ?≥) prettify-symbols-alist)
    (push '("=>" . ?⇒) prettify-symbols-alist))
#+END_SRC

Now apply the default to some modes I don't want anything special in.

#+BEGIN_SRC emacs-lisp :tangle yes
  (mapc
   (lambda (hook)
     (add-hook 'hook (lambda () (wolfe/pretty-symbol-push-default))))
   '(c-mode))
#+END_SRC

**** Python

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'python-mode-hook
            (lambda ()
              (wolfe/pretty-symbol-push-default)
              (push '("def"    . ?ƒ) prettify-symbols-alist)
              (push '("sum"    . ?Σ) prettify-symbols-alist)
              (push '("**2"    . ?²) prettify-symbols-alist)
              (push '("**3"    . ?³) prettify-symbols-alist)
              (push '("None"   . ?∅) prettify-symbols-alist)
              (push '("in"     . ?∈) prettify-symbols-alist)
              (push '("not in" . ?∉) prettify-symbols-alist)
              (push '("return" . ?➡) prettify-symbols-alist)
              (prettify-symbols-mode t)))
#+END_SRC

**** Lisp

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (wolfe/pretty-symbol-push-default)
              (push '("defun"    . ?ƒ) prettify-symbols-alist)
              (push '("defmacro" . ?μ) prettify-symbols-alist)
              (push '("defvar"   . ?ν) prettify-symbols-alist)
              (prettify-symbols-mode t)))
#+END_SRC

**** Go

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'go-mode-hook
            (lambda ()
              (wolfe/pretty-symbol-push-default)
              (push '("func"    . ?ƒ) prettify-symbols-alist)
              (push '(":="    . ?←) prettify-symbols-alist)
              (prettify-symbols-mode t)))
#+END_SRC

*** Column Marker

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package column-marker
    :ensure nil
    :config
    (add-hook 'prog-mode-hook (lambda () (interactive) (column-marker-1 81)))
    (custom-set-faces
     '(column-marker-1 ((t (:background "dim gray"))))))
#+END_SRC

*** Highlight Escape Characters

This defines 4 new faces and the appropriate =regexps= that highlight
them and maps them to all the modes in [[Highlight Escapes Modes][=wolfe/highlight-escapes-mode-list=]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (defface wolfe/backslash-escape-backslash-face
    '((t :inherit font-lock-regexp-grouping-backslash))
    "Face for the back-slash component of a back-slash escape."
    :group 'font-lock-faces)

  (defface wolfe/backslash-escape-char-face
    '((t :inherit font-lock-regexp-grouping-construct))
    "Face for the charcter component of a back-slash escape."
    :group 'font-lock-faces)

  (defface wolfe/format-code-format-face
    '((t :inherit font-lock-regexp-grouping-backslash))
    "Face for the % component of a printf format code."
    :group 'font-lock-faces)

  (defface wolfe/format-code-directive-face
    '((t :inherit font-lock-regexp-grouping-construct))
    "Face for the directive component of a printf format code."
    :group 'font-lock-faces)

  (mapc
   (lambda (mode)
     (font-lock-add-keywords
      mode
      '(("\\(\\\\\\)." 1 'wolfe/backslash-escape-backslash-face prepend)
        ("\\\\\\(.\\)" 1 'wolfe/backslash-escape-char-face      prepend)
        ("\\(%\\)."    1 'wolfe/format-code-format-face         prepend)
        ("%\\(.\\)"    1 'wolfe/format-code-directive-face      prepend))))
   wolfe/highlight-escapes-mode-list)
#+END_SRC

*** Highlight Todo, Fixme & Bug

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook
                 (lambda ()
                  (font-lock-add-keywords nil
                   '(("\\<\\(FIXME\\|TODO\\|BUG\\|XXX\\):" 1 font-lock-warning-face t)))))
#+END_SRC

** Personal Defaults

Nothing to crazy here just the type of behaviour I personally
expect as default.

#+BEGIN_SRC emacs-lisp :tangle yes
  (show-paren-mode t) ; Highlights matching parens
  (fset 'yes-or-no-p 'y-or-n-p) ; y/n instead of yes/no
  (blink-cursor-mode -1) ; No need to flash the cursor
  (column-number-mode t) ; Show column in mode-line
  (delete-selection-mode 1) ; Replace selection on insert
  (setq-default truncate-lines t ; Don't wrap
                indent-tabs-mode nil)
  (setq vc-follow-symlinks t ; Always follow symlinks
        tags-revert-without-query t ; Don't ask to reload TAGS file
        echo-keystrokes 0.5
        custom-file "~/.emacs.d/custom.el" ; Set custom file and don't load it
        source-directory "~/Projects/emacs/")
#+END_SRC

** Misc
*** Vim Scrolloff

This makes scrolling gradual rather than by half page. I find that the
half page scroll really makes me lose where I am in the file so here
I make sure to scroll one line at a time. In addition I want to keep
what I'm working on centered so I start scrolling when the cursor is
10 lines away from the margin.

This behaviour in general emulates the =scrolloff= option in vim.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq scroll-margin 10
        scroll-step 1
        scroll-conservatively 10000
        scroll-preserve-screen-position 1)
#+END_SRC

*** Shell Tweaks

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq explicit-shell-file-name
        (if (file-readable-p "/usr/bin/zsh") "/usr/bin/zsh" "/bin/bash"))
  (when (eq system-type 'windows-nt)
    (setq explicit-shell-file-name "cmdproxy.exe"))
#+END_SRC

*** Spell Check

#+BEGIN_SRC emacs-lisp :tangle yes
  (when wolfe/windows?
    (setq ispell-program-name "c:/emacs/hunspell/bin/hunspell.exe"))
#+END_SRC

*** Help & Compilation

Keep the output scrolling as it compiles.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'compile)
  (setq compilation-scroll-output t)
#+END_SRC

=q= should really quit the buffer not just stick it at the bottom.

#+BEGIN_SRC emacs-lisp :tangle yes
  (dolist (m (list help-mode-map compilation-mode-map))
    (bind-key (kbd "q") (lambda () (interactive) (quit-window t)) m))
#+END_SRC

** Mode Line

If we're in GUI emacs we make sure to use =powerline= otherwise we use
a custom mode line configuration.

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (or (display-graphic-p) (daemonp))
      (use-package doom-modeline
        :init
        (use-package anzu)
        (use-package evil-anzu)
        (setq evil-normal-state-tag   ""
              evil-emacs-state-tag    ""
              evil-insert-state-tag   ""
              evil-motion-state-tag   ""
              evil-visual-state-tag   ""
              evil-operator-state-tag "")
        :config
        (setq doom-modeline-bar-width 3)
        (custom-set-faces
         `(doom-modeline-bar ((t (:inherit default :background ,(face-foreground 'match))))))
        :defer t
        :hook (after-init . doom-modeline-init))
    (setq-default
     mode-line-format
     (list
      " "
      ;; is this buffer read-only?
      '(:eval (when buffer-read-only
                (propertize "RO"
                            'face 'font-lock-type-face
                            'help-echo "Buffer is read-only")))

      ;; was this buffer modified since the last save?
      '(:eval (when (buffer-modified-p)
                (propertize "M"
                            'face 'font-lock-warning-face
                            'help-echo "Buffer has been modified")))

      " "
      ;; the buffer name; the file name as a tool tip
      '(:eval (propertize "%b " 'face 'font-lock-keyword-face
                          'help-echo (buffer-file-name)))


      ;; the current major mode for the buffer.
      "["

      '(:eval (propertize (format-mode-line mode-name) 'face '(:family "Arial")
                          'help-echo buffer-file-coding-system))
      '(:eval (propertize (format-mode-line minor-mode-alist)
                          'face '(:family "Arial")))
      "]             "

      ;; line and column
      "(" ;; '%02' to set to 2 chars at least; prevents flickering
      (propertize "%02l" 'face 'font-lock-type-face) ","
      (propertize "%02c" 'face 'font-lock-type-face)
      ") "

      ;; relative position, size of file
      "["
      (propertize "%p" 'face 'font-lock-constant-face) ;; % above top
      "/"
      (propertize "%I" 'face 'font-lock-constant-face) ;; size
      "] "

      ;; add the time, with the date and the emacs uptime in the tooltip
      '(:eval (propertize (format-time-string "%H:%M")
                          'help-echo
                          (concat (format-time-string "%c; ")
                                  (emacs-uptime "Uptime:%hh")))))))

#+END_SRC

** Line Numbers

Vim-like relative line numbering. If we're on the latest versions of emacs
(i.e. =26.0.50= or higher) then we should use the native line numbering
otherwise we fall back to =nlinum-relative=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (if (version< "26.0.50" emacs-version)
      (progn
        (add-hook 'prog-mode-hook (lambda ()
                                    (display-line-numbers-mode t)
                                    (setq display-line-numbers 'relative))))
    (progn
      (use-package nlinum-relative
        :config
        (nlinum-relative-setup-evil)
        (setq nlinum-relative-redisplay-delay 0.25)
        (setq nlinum-relative-current-symbol "")
        (add-hook 'prog-mode-hook 'nlinum-relative-mode))))

#+END_SRC

* Functions
** Face Under Point

Returns the font lock face that's under the cursor.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Compile Project

Compiles the project without a prompt.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/compile-no-prompt ()
    (interactive)
    (let ((compilation-read-command nil))
      (compile (eval compile-command))))
#+END_SRC

** Compile Dotfiles

Compiles all el files in the =~/.emacs.d= directory.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/compile-dot-emacs ()
    "Byte-compile dotfiles."
    (interactive)
    (byte-recompile-directory user-emacs-directory 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/clear-all-elc ()
    (interactive)
    (shell-command "find ~/.emacs.d/ -name \"*.elc\" -type f -delete"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/remove-elc-on-save ()
    "If you're saving an emacs-lisp file, likely the .elc is no longer valid."
    (add-hook 'after-save-hook
              (lambda ()
                (if (file-exists-p (concat buffer-file-name "c"))
                    (delete-file (concat buffer-file-name "c"))))
              nil t))
  (add-hook 'emacs-lisp-mode-hook 'wolfe/remove-elc-on-save)
#+END_SRC

** Find Tags

Looks up tag under point.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/find-tag ()
    "Jump to the tag at point without prompting"
    (interactive)
    (find-tag (find-tag-default)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/create-tags ()
    "Create the tags table"
    (interactive)
    (save-window-excursion (shell-command "etags -R -o ETAGS *")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice xref-find-definitions (around refresh-etags activate)
    "Rerun etags and reload tags if tag not found and redo find-tag.
     If buffer is modified, ask about save before running etags."
    (condition-case err
        ad-do-it
      (error (and (buffer-modified-p) (not (ding))
                  (save-buffer))
             (save-window-excursion (shell-command "etags -R *"))
             ad-do-it)))
#+END_SRC

** Terminal Suspend

Fixes =C-z= in terminal.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/controlz ()
    (interactive)
    (when (eq (display-graphic-p) nil)
      (suspend-frame)))
#+END_SRC

** Dropbox

Utility functions for finding Dropbox directories/files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/org-open (name)
    "Opens the file in the dropbox path"
    (interactive)
    (evil-buffer-new nil (concat wolfe/org-dropbox-path name ".org")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/dropbox-start ()
    (interactive)
    (if (eq nil (file-exists-p "/virtual/wolfejos/dropbox/.dropbox-dist"))
        (call-process-shell-command "(python ~/.emacs.d/dropbox.py start -i&)")
      (call-process-shell-command "(python ~/.emacs.d/dropbox.py start&)")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/dropbox-stop ()
    (interactive)
    (call-process-shell-command "python ~/.emacs.d/dropbox.py stop&"))
#+END_SRC

** Reload

For reloading =init.el= file without restarting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/load-init ()
    "Reloads init file"
    (interactive)
    (load-file "~/.emacs.d/init.el"))
#+END_SRC

** Narrowing

Better narrowing.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))
#+END_SRC

** Man Replacement

Use the real =man= if I'm on a system that has the binary otherwise
we should just use the emacs =woman=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/man ()
    (if (executable-find "man")
        (man (word-at-point))
      (woman)))
#+END_SRC

** Hot Expand

Is used in one of my [[Hydra][hydras]] =wolfe/hydra-org-expand=. For inserting org-templates.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun hot-expand (str &optional additional-text)
    "Expand org template."
    (insert str)
    (org-try-structure-completion)
    (when additional-text
      (insert additional-text)
      (forward-line)))
#+END_SRC

** Projectile If-Else

This allows us to easily call a projectile version of a
function if we're inside of a project otherwise we can just
call the normal version. For example =projectile-ag= vs =ag=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/if-else-projectile (if-function else-function)
    "Calls the if-function if inside a project otherwise
  it calls the else-function"
    (interactive)
    (if (projectile-project-p)
        (call-interactively if-function)
      (call-interactively else-function)))
#+END_SRC

** Projectile Invalidate From List

Select project from list of projectile projects to invalidate.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/projectile-invalidate-list ()
    (interactive)
    (projectile-invalidate-cache t))
#+END_SRC

** User Pass Tupple

Uses GPG to decrypt =file= and returns a list of the contents split on spaces.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/get-user-pass (file)
    (split-string
     (car (last (split-string
                 (shell-command-to-string (concat "gpg --output - --decrypt "
                                                  (expand-file-name file)))
                 "[|\n]" t "[ 	\n]"))) " "))
#+END_SRC

** Ag Kill Buffers and Close Window

Kill all the open ag buffers and delete the window I'm in. This is bound
in my [[Ag][=ag config=]] in =ag-mode-map= so it will close the current =ag= window
and all the buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/ag-kill-buffers-and-window ()
    (interactive)
    (ag-kill-buffers)
    (delete-window))
#+END_SRC

** Org Tree Slides Set Transient Map

This function once called will keep a transient map active until =wolfe--enable-transient-map=
is set to nil at which point it will unbind the variable. This is used with [[Org Tree Slide][=org-tree-slide-mode=]]
to add custom bindings regardless of the mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/org-tree-set-transient-map ()
    (interactive)
    (if wolfe--enable-transient-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "<right>") 'org-tree-slide-move-next-tree)
          (define-key map (kbd "<left>")  'org-tree-slide-move-previous-tree)
          (define-key map (kbd "<up>")    'org-tree-slide-content)
          (define-key map (kbd "<down>")  'org-tree-slide-display-header-toggle)
          (set-transient-map map nil 'wolfe/org-tree-set-transient-map))
      (makeunbound wolfe--enable-transient-map)))
#+END_SRC

** Eval and Replace

This was stolen from [[https://github.com/bbatsov/prelude][prelude]] emacs. Over there it's called =prelude-eval-and-replace=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/eval-and-replace (beginning end)
    "Replace the preceding sexp or region with its value."
    (interactive "r")
    (if (region-active-p)
        (delete-region beginning end)
      (backward-kill-sexp))
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

#+END_SRC

** Call Function and Update Ex History

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/call-and-update-ex (fun)
    "Calls the function and updates `evil-ex-history' with the result"
    (interactive)
    (setq evil-ex-history (cons (format "e %s" (funcall fun)) evil-ex-history)))
#+END_SRC

* Org Mode
** General

Setup some basic quality of life org settings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-pretty-entities t
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'current-window
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-highlight-latex-and-related '(latex)
        org-log-done 'time
        org-enforce-todo-dependencies t
        org-agenda-use-time-grid nil
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-ellipsis wolfe/org-ellipsis)

  (defun wolfe/org-tags-compute-width ()
    (- (floor (* 0.8 (frame-width)))))

  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-tags-column (wolfe/org-tags-compute-width))
              (org-align-all-tags)))
  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (setq org-agenda-tags-column (wolfe/org-tags-compute-width))
              (org-agenda-align-tags)))

  (defun wolfe/save-org-archive-buffers (orig-fun &rest args)
    (save-some-buffers 'no-confirm
                       (lambda ()
                         (string-match "_archive\\'" buffer-file-name))))

  (advice-add 'org-archive-subtree :after 'wolfe/save-org-archive-buffers)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (  dot . t)))

  (global-set-key "\C-cl" 'org-store-link)

  ;; ispell ignores SRC blocks
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_LATEX" . "#\\+END_LATEX"))

  ;; Refresh images after executing a src block
  (add-hook 'org-babel-after-execute-hook
            (lambda ()
              (when org-inline-image-overlays
                (org-redisplay-inline-images))))

  (defun wolfe/confirm-babel-evaluate (lang body)
    (not (string= lang "dot")))
  (setq org-confirm-babel-evaluate 'wolfe/confirm-babel-evaluate)

  ;; Open PDFs with zathura
  (add-hook 'org-mode-hook
            (lambda ()
              (setq org-file-apps
                    (append '(("\\.pdf\\'" . "zathura \"%s\"")) org-file-apps))))
#+END_SRC

** Bullets

Replaces the asterisks with nice UTF-8 bullets.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** Agenda

Setup org agenda for managing my life.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-agenda
    :ensure nil
    :bind (("C-c a" . org-agenda)
           :map org-agenda-mode-map
           ("j" . org-agenda-next-item)
           ("k" . org-agenda-previous-item))
    :config
    ;; Formats the agenda into nice columns
    (setq org-agenda-prefix-format
          '((agenda . " %i %-12t% s %-12(car (last (org-get-outline-path)))")
            (timeline . "  % s")
            (todo . " %i %-12:c")
            (tags . " %i %-12:c")
            (search . " %i %-12:c")))

    ;; Sets location of org files
    (setq org-agenda-files `(,(concat wolfe/org-dropbox-path "everything.org")))
    (setq browse-url-browser-function 'browse-url-chromium))
#+END_SRC

** Capture

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key "\C-cc" 'org-capture)

  (setq org-default-notes-file (concat wolfe/org-dropbox-path "everything.org"))
  (setq org-capture-templates
        '(("t" "Task" entry (file+headline "" "Tasks")
           "* TODO %?\n  DEADLINE: %t\n")))
#+END_SRC

** Export

Setup html for syntax highlighting on export and add the apppropriate
minted package for PDF export.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package htmlize)

  (require 'ox-latex)
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-export-allow-bind-keywords t
        org-latex-listings 'minted)
  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Hugo

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ox-hugo
    :after ox)
#+END_SRC

** Org Tree Slide

Presentation mode that runs from within an org document. I add a custom hook for [[Org Tree Slides Set Transient Map][a function]] that
repeatedly creates a transient map replacing the controls regardless of my evil mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-tree-slide
    :config
    (add-hook 'org-tree-slide-mode-hook
              (lambda ()
                (if org-tree-slide-mode
                    ;; When mode is enabled
                    (progn (setq wolfe--enable-transient-map t)
                           (wolfe/org-tree-set-transient-map))
                  ;; When mode is disabled
                  (setq wolfe--enable-transient-map nil)))))
#+END_SRC

* Keymaps
** Hydra

Customizable popup menus.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hydra)
  (use-package major-mode-hydra
    :ensure nil)
#+END_SRC

*** Major Modes
**** C#

#+BEGIN_SRC emacs-lisp :tangle yes
  (major-mode-hydra-bind csharp-mode "Find"
    ("d" omnisharp-go-to-definition              "Goto definition")
    ("D" omnisharp-go-to-definition-other-window "Pop-open definition")
    ("u" omnisharp-find-usages                   "Find usages")
    ("p" omnisharp-find-implementations          "Find implementations"))

  (major-mode-hydra-bind csharp-mode "Fix/Refactor"
    ("r" omnisharp-rename                        "Rename symbol")
    ("f" omnisharp-run-code-action-refactoring   "Code action")
    ("i" omnisharp-code-format-region            "Indent region")
    ("I" omnisharp-code-format-entire-file       "Indent entire file"))

  (major-mode-hydra-bind csharp-mode "Solution"
    ("e" omnisharp-solution-errors               "Solution errors")
    ("a" omnisharp-add-to-solution-current-file  "Add current file to sln")
    ("s" omnisharp-reload-solution               "Reload solution"))
#+END_SRC

**** Python

#+BEGIN_SRC emacs-lisp :tangle yes
  (major-mode-hydra-bind python-mode "Python"
    ("i" elpy-importmagic-fixup "Importmagic fixup")
    ("d" elpy-goto-definition   "Goto definition")
    ("r" elpy-multiedit-python-symbol-at-point   "Rename symbol")
    ("f" elpy-format-code   "Format code")
    )
#+END_SRC

**** Org Mode

#+BEGIN_SRC emacs-lisp :tangle yes
  (major-mode-hydra-bind org-mode "Org Mode"
    ("t" (funcall wolfe/hydra-org-expand) "Expand template"))
#+END_SRC

**** Org Templates

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq wolfe/hydra-org-expand
        (defhydra hydra-org-template (:color blue :hint nil)
          "
          _c_enter  _q_uote    _L_aTeX:
          _l_atex   _e_xample  _i_ndex:
          _a_scii   _v_erse    _I_NCLUDE:
          _s_rc     _t_angle   _H_TML:
          _h_tml    _d_ot src  _A_SCII:
          "
          ("s" (hot-expand "<s"))
          ("e" (hot-expand "<e"))
          ("q" (hot-expand "<q"))
          ("v" (hot-expand "<v"))
          ("t" (hot-expand "<s" "emacs-lisp :tangle yes"))
          ("d" (hot-expand "<s" "dot :file TMP.png :cmdline -Kdot -Tpng"))
          ("c" (hot-expand "<c"))
          ("l" (hot-expand "<l"))
          ("h" (hot-expand "<h"))
          ("a" (hot-expand "<a"))
          ("L" (hot-expand "<L"))
          ("i" (hot-expand "<i"))
          ("I" (hot-expand "<I"))
          ("H" (hot-expand "<H"))
          ("A" (hot-expand "<A"))))
#+END_SRC

*** Minor Modes
**** Projectile

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq wolfe/hydra-projectile
        (pretty-hydra-define hydra-projectile (:exit t :hint nil)
          ("Files" (("f" counsel-projectile-find-file        "Find File")
                    ("d" counsel-projectile-find-dir         "Find Directory")
                    ("o" projectile-multi-occur              "Multi Occur")
                    ("s" counsel-projectile-switch-project   "Switch Project")
                    ("k" projectile-kill-buffers             "Kill Buffers"))

           "Cache" (("c" projectile-invalidate-cache         "Clear Cache")
                    ("C" wolfe/projectile-invalidate-list    "Clear A Cache")
                    ("P" projectile-clear-known-projects     "Clear Projects")))))
#+END_SRC

**** Jira

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/hydra-jira ()
    (interactive)
    (funcall
        (pretty-hydra-define hydra-jira (:exit t :hint nil)
          ("Get" (("p" org-jira-get-projects                "Get Projects")
                  ("g" org-jira-get-issues                  "Get Issues")
                  ("G" org-jira-get-subtasks                "Get Subtasks")
                  ("r" org-jira-refresh-issue               "Refresh Issue")
                  ("R" org-jira-refresh-issues-in-buffer    "Refresh Issues in Buffer"))

           "Manage" (("b" org-jira-browse-issue             "Browse Issue")
                     ("c" org-jira-create-issue             "Create Issue")
                     ("s" org-jira-create-subtask           "Create Subtask")
                     ("P" org-jira-progress-issue           "Update Issue Progress")
                     ("a" org-jira-assign-issue             "Assign Issue"))

           "Push" (("u" org-jira-update-issue                "Update Issue")
                   ("y" org-jira-copy-current-issue-key      "Copy Current Issue Key")
                   ("U" org-jira-update-comment              "Update Comment")
                   ("t" org-jira-todo-to-jira                "Todo to Jira"))))))
#+END_SRC

** Evil & General
*** General

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package general)
#+END_SRC

*** Evil

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil
    :demand
    :bind
    (:map evil-motion-state-map
          ("C-u" . evil-scroll-up))
    :init
    (setq evil-want-C-u-scroll t) ; Unbind <C-u> for evil mode's use
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode t)
    (setq evil-split-window-below t
          evil-vsplit-window-right t
          evil-lookup-func #'wolfe/man)
    (setq-default evil-symbol-word-search t)
    (custom-set-variables '(evil-search-module (quote evil-search)))
    (evil-ex-define-cmd "re[load]" 'wolfe/load-init) ; Custom reload command
    (evil-ex-define-cmd "Q" 'save-buffers-kill-terminal) ; For typos
    (define-key evil-ex-map "e " (lambda () (interactive) (wolfe/call-and-update-ex 'counsel-find-file))) ; Trigger file completion :e
    (global-unset-key (kbd "M-SPC")) ; Unbind secondary leader

    (general-create-definer wolfe/bind-leader
      :keymaps 'global
      :states '(normal insert visual emacs)
      :prefix "SPC"
      :non-normal-prefix "M-SPC")

    (general-define-key
     :states 'motion
     "k" 'evil-previous-visual-line
     "j" 'evil-next-visual-line)

    (general-define-key
     :states 'operator
     "k" 'evil-previous-line
     "j" 'evil-next-line)

    (general-define-key
     :states 'visual
     "<" (lambda ()
           (interactive)
           (evil-shift-left (region-beginning) (region-end))
           (evil-normal-state)
           (evil-visual-restore))
     ">" (lambda ()
           (interactive)
           (evil-shift-right (region-beginning) (region-end))
           (evil-normal-state)
           (evil-visual-restore)))

    (general-define-key
     :states 'normal
     "C-z"  'wolfe/controlz
     "C-l"  'evil-ex-nohighlight)

    (wolfe/bind-leader
      "w"  'save-buffer
      "S"  'wolfe/eval-and-replace
      "s"  'eval-defun
      "b"  'mode-line-other-buffer
      "k"  'kill-buffer
      "m"  'ivy-switch-buffer
      "e"  'iedit-mode
      "c"  'wolfe/compile-no-prompt
      "n"  'narrow-or-widen-dwim
      "a"  'org-agenda
      "g"  'magit-status
      "''" 'org-edit-src-exit
      "#"  'wolfe/csharp-project
      "t"    (lambda() (interactive) (wolfe/if-else-projectile 'treemacs-projectile 'treemacs))
      "f"    (lambda() (interactive) (wolfe/if-else-projectile 'counsel-projectile-ag 'counsel-ag))
      "p"    (lambda() (interactive) (funcall wolfe/hydra-projectile))
      ";"    (lambda() (interactive) (save-excursion (end-of-line) (insert-char ?\;)))
      "id"   (lambda() (interactive) (indent-region (point-min) (point-max)))
      "o"    (lambda() (interactive) (wolfe/org-open "everything"))
      "init" (lambda() (interactive) (evil-buffer-new nil wolfe/init-file))
      "SPC"  'major-mode-hydra))
#+END_SRC

*** Evil Surround

Tpope's surround

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-surround
      :config
      (global-evil-surround-mode 1))
#+END_SRC

*** Evil Machit

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil-matchit
      :config
      (global-evil-matchit-mode 1))

#+END_SRC

*** Evil Visual Star

This allows me to easily start a =*= or =#= search from a visual selection.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil-visualstar
    :config
    (global-evil-visualstar-mode))
#+END_SRC

*** Evil Numbers

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil-numbers
    :bind
    (:map evil-normal-state-map
          ("C-a" . 'evil-numbers/inc-at-pt)
          ("C--" . 'evil-numbers/dec-at-pt)))

#+END_SRC

*** Evil Lion

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil-lion
    :config
    (evil-lion-mode))
#+END_SRC

*** Evil Exchange

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package evil-exchange
    :config
    (evil-exchange-install))
#+END_SRC

* Project Management
** Ag

Emacs interface for ag

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ag
    :bind (:map ag-mode-map
           ("Q" . wolfe/ag-kill-buffers-and-window)))
#+END_SRC

** Magit

Magic git interface from within emacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :defer 10
    :config
    (use-package evil-magit)
    (setq magit-bury-buffer-function
          (lambda (con)
            (kill-buffer)
            (delete-window))))
#+END_SRC

** Projectile

Project management

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :config
    (use-package counsel-projectile
      :config
      (counsel-projectile-mode))
    (setq projectile-enable-caching t)
    (setq projectile-indexing-method 'alien)
    (setq projectile-globally-ignored-file-suffixes
          '("#" "~" ".swp" ".o" ".so" ".exe" ".dll" ".elc" ".pyc" ".jar" "*.class"))
    (setq projectile-globally-ignored-directories
          '(".git" "node_modules" "__pycache__" ".vs"))
    (setq projectile-globally-ignored-files '("TAGS" "tags" ".DS_Store"))
    (projectile-mode))
#+END_SRC

** Treemacs

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package treemacs
    :config
    (setq treemacs-follow-after-init t
          treemacs-width             35
          treemacs-indentation       2))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package treemacs-evil)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package treemacs-projectile)
#+END_SRC

** Dumb Jump

Automatically =grep= or =ag= through a project for a definition. This
is useful when semantic jump to definition or =TAGS= files aren't present
or don't exist for the language.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dumb-jump
    :bind
    (:map evil-normal-state-map
          ("g D" . dumb-jump-go))
    :config
    (setq dumb-jump-selector 'ivy))
#+END_SRC

** Persp Mode
   
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package persp-mode
    :hook (after-init . (lambda () (persp-mode 1)))
    :config
    (defvar wolfe/persp-default-workspace "main")
    (defvar wolfe/persp-shared-buffers '("*scratch*" "*Messages*"))

    (setq wg-morph-on nil ;; switch off animation
          persp-autokill-buffer-on-remove 'kill-weak
          persp-auto-save-opt 0
          persp-auto-resume-time -1
          persp-nil-hidden t
          persp-add-buffer-on-find-file t
          persp-add-buffer-on-after-change-major-mode nil
          persp-hook-up-emacs-buffer-completion t)

    ;; Make ivy play nice
    (with-eval-after-load "ivy"
      (add-hook 'ivy-ignore-buffers
                #'(lambda (b)
                    (when persp-mode
                      (let ((persp (get-current-persp)))
                        (if persp
                            (not (persp-contain-buffer-p b persp))
                          nil)))))
      (setq ivy-sort-functions-alist
            (append ivy-sort-functions-alist
                    '((persp-kill-buffer   . nil)
                      (persp-remove-buffer . nil)
                      (persp-add-buffer    . nil)
                      (persp-switch        . nil)
                      (persp-window-switch . nil)
                      (persp-frame-switch . nil)))))

    (defun wolfe/persp-switch-project-action ()
      (let ((frame (selected-frame))
            (name (projectile-project-name)))
        (with-selected-frame frame
          (persp-add-new name)
          (persp-frame-switch name)
          (persp-add-buffer wolfe/persp-shared-buffers (get-current-persp) nil)
          (run-with-timer 0 nil (lambda () (persp-add-buffer (current-buffer)))))))

    (add-hook 'projectile-after-switch-project-hook 'wolfe/persp-switch-project-action)

    (defun wolfe/persp-concat-name (count)
      (if (eq count 0)
          wolfe/persp-default-workspace
        (format "%s-%s" wolfe/persp-default-workspace count)))

    (defun wolfe/persp-next-main-name (&optional count)
      (let ((count (or count 0)))
        (if (persp-with-name-exists-p (wolfe/persp-concat-name count))
            (wolfe/persp-next-main-name (+ count 1))
          (wolfe/persp-concat-name count))))

    (add-hook
     'after-make-frame-functions
     (lambda (frame)
       (let ((name (wolfe/persp-next-main-name)))
         (with-selected-frame frame
           (message "Making persp %s" name)
           (persp-add-new name)
           (persp-add-buffer wolfe/persp-shared-buffers (get-current-persp) nil)
           (persp-frame-switch name frame))))))
#+END_SRC

* Languages
** Generic Web
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package web-mode
    :mode ("\\.html\\'" "\\.php\\'" "\\.js\\'")
    :config
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-opening t)
    (setq web-mode-enable-auto-indentation t))

  (use-package json-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-restclient
    :after company
    :config
    (add-to-list 'company-backends 'company-restclient))
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-tern
    :after company
    :config
    (add-to-list 'company-backends 'company-tern)
    (add-hook 'web-mode-hook 'tern-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package indium)
#+END_SRC

Basic editing mode for React.js files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rjsx-mode)
#+END_SRC

** Lisp Family

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package parinfer
    :defer t
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (setq
     parinfer-extensions '(defaults pretty-parens evil smart-tab smart-yank)
     parinfer-lighters '(" Φi" . " Φp"))
    (add-hook 'racket-mode           #'parinfer-mode)
    (add-hook 'clojure-mode-hook     #'parinfer-mode)
    (add-hook 'emacs-lisp-mode-hook  #'parinfer-mode)
    (add-hook 'common-lisp-mode-hook #'parinfer-mode)
    (add-hook 'scheme-mode-hook      #'parinfer-mode)
    (add-hook 'lisp-mode-hook        #'parinfer-mode))
#+END_SRC

** Racket

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package racket-mode
    :defer t)
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package haskell-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck-haskell
    :after flycheck
    :config
    (add-hook 'haskell-mode-hook #'flycheck-haskell-setup))
#+END_SRC

** Latex

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package latex-preview-pane
    :defer t
    :ensure f)
#+END_SRC

** C/C++

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq gdb-many-windows t
        gdb-show-main t
        company-clang-insert-arguments nil)

  (use-package company-irony
    :after company
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony)))
#+END_SRC

** C#

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package omnisharp
    :after company
    :config
    (when wolfe/windows?
      (setq omnisharp-server-executable-path "C:/emacs/omnisharp/Omnisharp.exe"))
    (add-hook 'csharp-mode-hook
              (lambda ()
                (evil-define-key 'normal omnisharp-mode-map (kbd "g d") 'omnisharp-go-to-definition)
                (unless (file-exists-p "Makefile")
                  (set (make-local-variable 'compile-command) (concat "msbuild " (cdr (assoc :project-root omnisharp--server-info)))))))
    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    (add-to-list 'company-backends 'company-omnisharp))
#+END_SRC

** Python

I explicitly load the python package so that I can defer it
and =elpy= together since elpy is a bit slow to load at startup.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package python
    :defer 10
    :hook python-mode-hook)

  (use-package elpy
    :after (company python)
    :init (elpy-enable)
    :config
    (setq elpy-rpc-backend "jedi")
    (when (executable-find "ipython")
      (setq python-shell-interpreter "ipython"
            python-shell-interpreter-args "-i --simple-prompt"))

    (delete 'elpy-module-highlight-indentation elpy-modules)
    (delete 'elpy-module-flymake elpy-modules))
#+END_SRC

** Shell Scripts

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-shell
    :after company
    :config
    (add-to-list 'company-backends '(company-shell company-shell-env)))
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package go-mode
    :config
    (add-hook 'go-mode-hook (lambda () (setq tab-width 4))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-go
    :after company
    :config
    (when wolfe/linux?
      (add-to-list 'exec-path "~/Projects/go/bin"))
    (add-to-list 'company-backends 'company-go))
#+END_SRC

** Nim

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nim-mode
    :defer t)
#+END_SRC

** Java

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company-emacs-eclim
    :after company
    :config
    (company-emacs-eclim-setup)
    (setq eclimd-autostart t)

    (defun my-java-mode-hook ()
        (eclim-mode t))

    (add-hook 'java-mode-hook 'my-java-mode-hook))
#+END_SRC

* Utility
** Ranger

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ranger
    :config
    (setq ranger-cleanup-on-disable t)
    (ranger-override-dired-mode t))
#+END_SRC

** Iedit

Edit all instances of a string

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package iedit
    :config
    (set-face-attribute 'iedit-occurrence nil :foreground (face-attribute 'match :foreground))
    (setq iedit-toggle-key-default nil))
#+END_SRC

** Quick Run

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package quickrun
    :defer t)
#+END_SRC

** Restclient

Postman inside of emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package restclient
    :defer t)
#+END_SRC

** Rainbow Mode

Shows hex colors inline.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :defer t)
#+END_SRC

** Helpful

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helpful
    :defer t
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-h F" . helpful-function)
     ("C-h C" . helpful-command))
    :config
    (evil-define-key 'normal helpful-mode-map (kbd "q") 'kill-buffer-and-window)
    (set-face-attribute 'helpful-heading nil :height 1.1))
#+END_SRC

** Shackle

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package shackle
    :config
    (setq shackle-default-alignment 'below
          shackle-default-size 0.4
          shackle-rules
          '(("*HTTP Response*" :popup t :align right)))
    (shackle-mode))
#+END_SRC

** Zoom

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package zoom
    :config
    (setq zoom-size '(0.618 . 0.618))
    (zoom-mode t))
#+END_SRC

* Completion
** Ivy & Counsel

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ivy
    :demand
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           :map ivy-minibuffer-map
           ("TAB" . ivy-next-line)
           ("RET" . ivy-alt-done)
           :map ivy-switch-buffer-map
           ("C-d" . ivy-switch-buffer-kill))
    :init
    (use-package smex)
    (use-package counsel)
    :config
    (setq ivy-re-builders-alist
          '((t . ivy--regex-ignore-order)))
    (setq ivy-wrap t)
    (ivy-mode 1)

    (use-package doom-todo-ivy
      :ensure nil
      :config
      (evil-define-command doom/ivy-tasks-ex (&optional bang)
        "An ex wrapper around `doom/ivy-tasks'."
        (interactive "<!>")
        (doom/ivy-tasks bang))
      (evil-ex-define-cmd "todo" 'doom/ivy-tasks-ex))

    (eval-after-load "hydra" (use-package ivy-hydra)))
#+END_SRC

** Swiper

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package swiper
  :bind (("C-s" . swiper)))
#+END_SRC

** Company

Autocomplete engine

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :bind (:map company-active-map
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :init
    (global-company-mode)
    :config
    (setq company-idle-delay 0) ; Delay to complete
    (setq company-minimum-prefix-length 1)
    (setq company-selection-wrap-around t) ; Loops around suggestions

    (if (display-graphic-p)
        (define-key company-active-map [tab] 'company-select-next)
      (define-key company-active-map (kbd "C-i") 'company-select-next))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'color)
  (let ((bg (face-attribute 'default :background))
        (ac (face-attribute 'match :foreground)))
    (custom-set-faces
     `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
     `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
     `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
     `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
     `(company-tooltip-common ((t (:inherit font-lock-constant-face))))
     `(company-preview-common ((t (:foreground ,ac :background ,(color-lighten-name bg 10))))))))
#+END_SRC

** Flycheck Linting

On the fly syntax checking

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :config
    (global-flycheck-mode)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

** Yasnippet

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :config
    (yas-global-mode 1))
#+END_SRC

* Misc
** Email

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'epa-file)
  (custom-set-variables '(epg-gpg-program  "c:/Program Files (x86)/GNU/GnuPG/pub/gpg2"))
  (epa-file-enable)

  (require 'gnus)
  (setq user-mail-address "joshuafwolfe@gmail.com"
        user-full-name "Josh Wolfe")

  (setq gnus-select-method
        '(nnimap "gmail"
           (nnimap-address "imap.gmail.com")
           (nnimap-server-port 993)
           (nnimap-stream ssl)))

  (setq smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

  (setq gnus-thread-sort-functions
        '(gnus-thread-sort-by-most-recent-date
          (not gnus-thread-sort-by-number)))

  (defun my-gnus-group-list-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key gnus-group-mode-map
    ;; list all the subscribed groups even they contain zero un-read messages
    (kbd "o") 'my-gnus-group-list-subscribed-groups)
#+END_SRC

** IRC

My =erc= settings are pretty basic. I have the fill column recalculate
on window resize and I put the scroll margin back to default so that my
[[Vim Scrolloff][scrolloff]] settings don't mess with it.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package erc
    :ensure nil
    :defer t
    :config
    (add-hook 'window-configuration-change-hook
              (lambda ()
                (setq erc-fill-column (- (window-width) 2))))
    (add-hook 'erc-mode-hook
              (lambda ()
                (setq-local scroll-margin 1)))

    (setq erc-rename-buffers t
          erc-interpret-mirc-color t
          erc-lurker-hide-list '("JOIN" "PART" "QUIT")
          erc-autojoin-channels-alist '(("freenode.net" "#emacs"))))
#+END_SRC

Simple function that pulls my credentials from a GPG encrypted file
and connects to =freenode= providing a nick and password to verify my user.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/irc ()
        (interactive)
        (let* ((tupple (wolfe/get-user-pass wolfe/irc-info-path))
               (user (car tupple))
               (pass (cadr tupple)))
          (erc
           :server "irc.freenode.net"
           :port 6667
           :nick user
           :password pass)))
#+END_SRC

** Meme

Meme creator from within emacs... what more is there to say?

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package meme
    :ensure nil
    :commands (meme meme-file))
#+END_SRC

* Backups

Stores all backups and temp files in =~/.bak.emacs/=

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq backup-by-copying t) ; Stop shinanigans with links
  (setq backup-directory-alist '((".*" . "~/.bak.emacs/backup/")))
  ;; Creates directory if it doesn't already exist
  (make-directory "~/.bak.emacs/" t)
  ;; Creates auto directory if it doesn't already exist
  (make-directory "~/.bak.emacs/auto" t)
  ;; backup in one place. flat, no tree structure
  (setq auto-save-file-name-transforms '((".*" "~/.bak.emacs/auto/" t)))
#+END_SRC

* Testing
** Org Project

#+BEGIN_SRC emacs-lisp :tangle yes
  (let ((todo-file-path "~/Projects/todo-projectile/todo-projectile.el"))
    (when wolfe/windows?
      (setq todo-file-path "c:/dev/SideProjects/todo-projectile/todo-projectile.el"))
    (when (file-exists-p todo-file-path)
      (load-file todo-file-path)
      (setq todo-projectile-use-ag t)))
#+END_SRC

** Extract Dates

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun wolfe/extract-dates (file-path)
    "Parse through a file for a list of all the comments"
    (let (already-open
          buf
          start
          (comments '()))
      (setq already-open (find-buffer-visiting file-path)
            buf (find-file-noselect file-path))
      (with-current-buffer buf
        (goto-char (point-min))
        (while (setq start (text-property-any
                            (point) (point-max)
                            'face 'org-date))
          (goto-char start)
          (goto-char (next-single-char-property-change (point) 'face))
          (let ((item (string-trim (buffer-substring-no-properties start (point)))))
            (setq comments (cons item comments)))))
      (unless already-open (kill-buffer buf))
      (reverse comments)))
#+END_SRC
